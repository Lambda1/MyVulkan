原文: https://vulkan-tutorial.com/Overview

Origin of Vulkan
1.
Vulkanは以前のAPIと同様に, GPUを用いたクロスプラットフォームの抽象化を行っている.
以前のAPIの問題は, 固定機能がほとんど制限されていたグラフィックハードウェアを使用していたことで, プログラマーは, 頂点データを標準形式で作成する必要があり, 照明とシェーディングに関してはGPU製造業者に依存していた.
2.
グラフィックハードウェアが成長するにつれて, 多数のプログラム機能の追加が行われた.(OpenGL3以降の背景がそれに近い?)
このため, ゲームなどでパフォーマンスを改善するために, ドライバーの更新が多かった.
また, ドライバーは複雑なので, ハードウェアの不一致をシェーダにによって対処してきた.
これとは別に, 強いグラフィックハードウェアの登場により, モバイル向けなどが賑わい, いろいろあって, プログラマが細かく制御できるようになった.
けど, マルチスレッドのサポートが制限されているので, CPU側でボトルネック.(OpenGLはマルチスレッドに非対応の原因ぽい)
3.
Vulkanはこの問題を解決するために生まれた.(GDCのVulkan話がコレかな)
プログラマーが詳細なAPIを使用して明確にコマンド実行することで, ドライバーのオーバヘッドを削減し, マルチスレッドがコマンドの並行走査が可能となる.

What it takes to draw a triangle
三角形描画の基本を述べる.
Step1 Instance and physical device selection
 Vulkanアプリケーションは, VKInstanceを介してVulkan APIをセットアップする.
 インスタンスは, アプリケーションと使用するAPI拡張機能を記述することで作成される.
 インスタンス作成後, Vulkanがサポートするハードウェアを介して, 操作に使用する1つ以上のVkPhyscalDevicesを選択可能.
 VRAMサイズやデバイス機能などのプロパティを紹介して, 専用グラフィックカードを使用するなど, 目的のデバイスを選択できる.
Step 2 - Logical device and queue families
 使用するハードウェアデバイスを選択後, VkDevice(論理デバイス)を作成する必要がある.
 また, 使用するキューファミリを指定する必要がある.
 描画コマンドやメモリ操作など, Vulkanで実行されるほとんどの操作は, VkQueueに送信することで非同期に実行される.
 キューはキューファミリから割り当てられ, 各キューファミリはキュー内の特定の操作セットをサポートする.
 たとえば, グラフィックス, 計算, およびメモリ転送操作用に個別のキューファミリが存在する場合がある.
 キューファミリの可用性は, 物理デバイスの選択における際立った要因としても使用できる.
 Vulkanをサポートするデバイスは, グラフィック機能を提供しない可能性があるが, 現在のVulkanをサポートするすべてのグラフィックカードは, 一般的にすべてのキュー操作をサポートする.
Step 3 - Window surface and swap chain
 オフスクリーンレンダリング時は関係ないが, レンダリングする場合はウィンドウを作成する必要がある.
 ウィンドウには, ネイティブWin, GLFWやSDLなどの選択肢がある.
 実際のウィンドウにレンダリングするには, VksurfaceKHR(ウィンドウサーフェス)とVkSwapchainKHR(スワップチェーン)の2つが必要.
 
 これは, Vulkan APIがプラットフォームに依存しないためであり, 標準化されたWSI(Windows System Interface)拡張機能を使用してウィンドウマネージャと対話する必要がある.
 サーフェスは, レンダリングするウィンドウ上のクロスプラットフォームの抽象化であり, 通常, Windows状のHWNDなどのネイティブウィンドウハンドルへの参照を提供することでインスタンス化される.
 GLFWライブラリには, これに関するプラットフォーム固有の詳細を処理するための組み込み関数がある,

 スワップチェーンは, レンダーターゲットのコレクションである.(適当翻訳)
 目的は, レンダリングしている画像が, 画面上にある画像と異なることを保証することであり, これは完全な画像のみが表示されるために必要.(ダブルバッファリング的なもの?)
 フレームを描画するたびに, スワップチェーンにレンダリングするイメージを提供するように依頼する必要がある.
 フレームの描画が完了すると, 画像はスワップチェーンに戻され, ある時点で画面に表示される.
 レンダリングターゲットの数と完成した画像を画面に表示するための条件は,現在のモードによって異なる.
 現在の一般的なモードは, ダブルバッファリング(vsync)とトリプルバッファリングである.

 一部のプラットフォームでは, VK_KHR_display, およびVK_KHR_display_swapchain拡張機能を介してウィンドウマネージャーと対話することなく, ディスプレイに直接レンダリング可能.
 これらを使用すると, 画面全体を表すサーフェスを作成でき, たとえば, 独自のウィンドウマネージャを実装するために使用される.

Step 4 - Image views and framebuffers
 スワップチェーンから取得した画像に描画するには, VkImageViewとVkFramebufferにラップする必要がある.
 画像ビューは, 使用される画像の特定の部分を参照し, フレームバッファは, 色, 深度, ステンシルターゲットに使用される画像ビューを参照する.
 スワップチェーンには, 多くの異なる画像が存在する可能性があるため, それぞれの画像ビューとフレームバッファをプリエンプティブに作成し, 描画時に適切なものを選択する.

Step 5 - Render passes
 Vulkanのレンダーパスは, レンダリング操作中に使用される画像の種類, それらの使用方法, およびコンテンツの処理方法を記述する.
 最初の三角形レンダリングアプリケーションでは, 単一の画像をカラーターゲットとして使用し, 描画操作の直前に単色にクリアすることをVulkanに指示する.
 レンダーパスは, 画像のタイプのみを記述するのに対して, VkFramebufferは実際に特定の画像をこれらのスロットにバインドする.

Step 6 - Graphics pipeline
 Vulkanのグラフィックパイプラインは, VkPipelineオブジェクトを作成することにより設定される.
 ビューポートのサイズや深度バッファーの操作, VkShaderModuleオブジェクトを使用したプログラム可能な状態など, グラフィックカードの構成可能な状態について説明する.
 VkShaderModuleオブジェクトは, シェーダーバイトコードから作成される.
 また, ドライバーはパイプラインで使用されるレンダーターゲットを知る必要があり, これは, レンダーパスを参照して指定する.

 既存のAPIと比較したVulkanの最も特徴的な機能の1つは, グラフィックパイプラインのほとんどすべての構成を事前に設定する必要があることであり, つまり, 別のシェーダーに切り替えるか, 頂点レイアウトをわずかに変更する場合は, グラフィックパイプラインを完全に再作成する必要がある.
 これは, レンダリング操作に必要なさまざまな組み合わせすべてに対して, 事前に多くのVkPipelineオブジェクトを作成する必要がある.
 動的に変更できるのは, ビューポートサイズやクリアカラーなどの基本的な構成のみであり, すべての状態も明示的に記述する必要があるため, たとえば, デフォルトのカラーブレンド状態はない

 良いニュースは, 事前コンパイルとジャストインタイムコンパイルを同等に行うため, ドライバーの最適化の機会が増え, ランタイムのパフォーマンスが予測可能になることであり, さまざまなグラフィックパイプラインが非常に明示的に作成される.

Step 7 - Command pools and command buffers
 前述のように, 描画操作など, 実行するVulkanの操作の多くは, キューに送信する必要がある.
 これらの操作は, 送信前にVkCommandBufferに記録する必要がある.
 これらのコマンドバッファは, 特定のキューファミリに関連付けられているVkCommandPoolから割り当てられる.
 単純な三角形を描くには, 次の操作でコマンドバッファーを記録する必要がある.
  1. Begin the render pass
  2. Bind the graphics pipeline
  3. Draw 3 vertices
  4. End the render pass
 フレームバッファ内の画像は, スワップチェーンが提供する特定の画像に依存するため, 可能な画像ごとにコマンドバッファを記録し, 描画時に適切なものを選択する必要がある.
 別の方法は, コマンドバッファをフレームごとに再度記録することだが, これは効率的ではない.

Step 8 - Main loop
 描画コマンドがコマンドバッファーにラップされたので, メインループは非常に単純.
 まず, vkAcquireNextImageKHRを使用してスワップチェーンからイメージを取得する.
 次に, そのイメージに適切なコマンドバッファーを選択し, vkQueueSubmitで実行する.
 最後に, vkQueuePresentKHRを使用して画面に表示するために, 画像をスワップチェーンに返す.

 キューに送信される操作は非同期に実行され, したがって, セマフォなどの同期オブジェクトを使用して, 正しい実行順序を確保する必要がある.
 描画コマンドバッファの実行は, 画像の取得が完了するまで待機するように設定する必要があり, そうでないと, 画面上で表示するために読み取り中の画像へのレンダリングが開始される場合がある.
 次に, vkQueuePresentKHR呼び出しは, レンダリングが完了するまで待機する必要がある.
 このため, レンダリングの完了後に通知される2番目のセマフォを使用する.

Summary
 実世界のプログラムには, 頂点バッファーの割り当て, 均一なバッファーの作成, 後続の章で説明するテクスチャイメージのアップロードなどのステップが含まれていますが, Vulkanには急勾配の学習曲線が十分にあるため, 簡単に始められる.
 頂点バッファーを使用する代わりに, 最初に頂点シェーダーに頂点座標を埋め込むことにより, 少しごまかせる.
 頂点バッファを管理するには, まずコマンドバッファにある程度精通している必要があるためである.
 要するに, 最初の三角形を描くには,
  1.  Create a VkInstance
  2.  Select a supported graphics card (VkPhysicalDevice)
  3.  Create a VkDevice and VkQueue for drawing and presentation
  4.  Create a window, window surface and swap chain
  5.  Wrap the swap chain images into VkImageView
  6.  Create a render pass that specifies the render targets and usage
  7.  Create framebuffers for the render pass
  8.  Set up the graphics pipeline
  9.  Allocate and record a command buffer with the draw commands for every possible swap chain image
  10. Draw frames by acquiring images, submitting the right draw command buffer and returning the images back to the swap chain

API concepts
  この章は, Vulkan APIが下位レベルでどのように構成されるかについての簡単な概要で締める.
Coding conventions
  すべてのVulkan関数, 列挙, および構造体は, Vulkan.hヘッダーで定義される.
  これは, LunarGが開発したVulkan SDKに含まれている.

  関数には小文字のvkプレフィックスがあり, 列挙型や構造体のような型にはVkプレフィックスがあり, 列挙値にはVK_プレフィックスがある.
  APIは, 関数にパラメーターを提供するために構造体を頻繁に使用し, たとえば, オブジェクトの作成は一般に次のパターンに従う.(略)

  Vulkanの多くの構造では, sTypeメンバーに構造のタイプを明示的に指定する必要がある.
  pNextメンバーは拡張構造を指すことができ, このチュートリアルでは常にnullptrになる.
  オブジェクトを作成または破棄する関数には, ドライバーメモリにカスタムアロケーターを使用できるVkAllocationCallbacksパラメーターがあり, このパラメーターは. このチュートリアルではnullptrのまま.
  
  ほとんどすべての関数は, VK_SUCCESS, またはエラーコードのいずれかであるVkResultを返す.
  仕様では, 各関数が返すことができるエラーコードとその意味を説明する.
Validation layers
  前述のように, Vulkanは高性能でドライバーのオーバーヘッドが少ないように設計されている.
  したがって, デフォルトでは非常に限られたエラーチェックとデバッグ機能が含まれる.
  何か間違ったことをすると, ドライバーはエラーコードを返す代わりにクラッシュすることがよくあり, さらに悪いことに, グラフィックカードでは動作し, 他では完全に失敗するように見える.

  Vulkanでは, 検証レイヤーと呼ばれる機能を使用して広範なチェックを有効にできる.
  検証レイヤーは, APIとグラフィックドライバーの間に挿入して, 関数パラメーターの追加チェックの実行やメモリ管理の問題の追跡などを行うことができるコードである.
  良い点は, 開発中にそれらを有効にし, アプリケーションをオーバーヘッドなしでリリースするときに完全に無効にできること.
  誰でも独自の検証レイヤーを作成できるが, LunarGのVulkan SDKは, このチュートリアルで使用する検証レイヤーの標準セットを提供する.
  また, コールバック関数を登録して, レイヤーからデバッグメッセージを受信する必要がある.

  Vulkanはすべての操作について非常に明確であり, 検証レイヤーは非常に広範囲に及ぶため, OpenGLやDirect3Dと比較して画面が黒い理由を見つけるのは実際にははるかに簡単.
